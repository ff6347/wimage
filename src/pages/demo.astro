---
// ABOUTME: Demo page with automatic chained workflow from image capture to visualization
// ABOUTME: Chains all API calls automatically and displays final result in fullscreen
import Footer from "../components/Footer.astro";
import "../styles/shared.css";
---

<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Wimage Demo - Automatic Workflow</title>
	</head>
	<body>
		<div class="camera-container" id="cameraContainer">
			<video id="video" autoplay playsinline></video>
			<canvas id="canvas" style="display: none;"></canvas>

			<div class="controls">
				<button id="startCamera">Start Camera</button>
				<button id="capture" disabled>Capture Image</button>
			</div>

			<div class="loading-section hidden" id="loadingSection">
				<div class="loading-spinner"></div>
				<div id="loadingMessage">
					<span id="loadingPrefix">Processing</span>
					<span id="loadingWord">...</span>
				</div>
			</div>
		</div>

		<Footer />

		<div id="visualizationContainer" class="hidden"></div>

		<style>
			html,
			body {
				width: 100%;
				height: 100%;
				max-width: 100%;
				overflow-x: hidden;
			}

			body {
				align-items: center;
				overflow-y: auto;
			}

			.camera-container {
				width: 640px;
				max-width: 100%;
				display: flex;
				flex-direction: column;
				gap: 8px;
				padding: 20px 20px 0 20px;
				justify-content: center;
				flex: 1 0 auto;
			}

			video {
				width: 100%;
				height: auto;
				aspect-ratio: 4 / 3;
				background: lightgray;
				display: block;
			}

			.controls {
				display: flex;
				gap: 8px;
				justify-content: center;
			}

			.loading-section {
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				gap: 8px;
				width: 100%;
			}

			.loading-spinner {
				width: 60px;
				height: 60px;
				border: 4px solid #f3f3f3;
				border-top: 4px solid #0066cc;
				border-radius: 50%;
				animation: spin 1s linear infinite;
			}

			@keyframes spin {
				0% {
					transform: rotate(0deg);
				}
				100% {
					transform: rotate(360deg);
				}
			}

			#loadingMessage {
				display: flex;
				gap: 0.5rem;
				font-size: 18px;
				color: #333;
				justify-content: center;
				align-items: center;
			}

			#loadingPrefix {
				flex-shrink: 0;
			}

			#loadingWord {
				min-width: 150px;
				text-align: left;
			}

			#visualizationContainer {
				width: 100%;
				height: 100vh;
				position: fixed;
				top: 0;
				left: 0;
				background: white;
				z-index: 9999;
			}

			#visualizationContainer iframe {
				width: 100%;
				height: 100%;
				border: none;
			}
		</style>

		<script>
			interface WikiArticle {
				title: string;
				text: string;
			}

			interface Summary {
				title: string;
				summary: string;
			}

			let stream: MediaStream | null = null;
			let capturedBlob: Blob | null = null;

			const video = document.getElementById("video") as HTMLVideoElement;
			const canvas = document.getElementById("canvas") as HTMLCanvasElement;
			const startCameraBtn = document.getElementById(
				"startCamera",
			) as HTMLButtonElement;
			const captureBtn = document.getElementById(
				"capture",
			) as HTMLButtonElement;
			const cameraContainer = document.getElementById(
				"cameraContainer",
			) as HTMLDivElement;
			const loadingSection = document.getElementById(
				"loadingSection",
			) as HTMLDivElement;
			const loadingPrefix = document.getElementById(
				"loadingPrefix",
			) as HTMLSpanElement;
			const loadingWord = document.getElementById(
				"loadingWord",
			) as HTMLSpanElement;
			const visualizationContainer = document.getElementById(
				"visualizationContainer",
			) as HTMLDivElement;

			function updateLoadingMessage(message: string) {
				// For backwards compatibility with non-streaming messages
				loadingPrefix.textContent = message;
				loadingWord.textContent = "";
			}

			function updateLoadingMessageParts(prefix: string, word: string) {
				loadingPrefix.textContent = prefix;
				loadingWord.textContent = word;
			}

			function showLoading() {
				loadingSection.classList.remove("hidden");
			}

			function hideCamera() {
				video.style.display = "none";
				document
					.querySelector(".controls")
					?.setAttribute("style", "display: none;");
			}

			startCameraBtn.addEventListener("click", async () => {
				try {
					stream = await navigator.mediaDevices.getUserMedia({
						video: { facingMode: "user" },
					});
					video.srcObject = stream;
					captureBtn.disabled = false;
					startCameraBtn.disabled = true;
				} catch (error) {
					alert(
						`Error accessing camera: ${error instanceof Error ? error.message : "Unknown error"}`,
					);
				}
			});

			captureBtn.addEventListener("click", async () => {
				const context = canvas.getContext("2d");
				if (!context) return;

				canvas.width = video.videoWidth;
				canvas.height = video.videoHeight;
				context.drawImage(video, 0, 0);

				canvas.toBlob(async (blob) => {
					if (blob) {
						capturedBlob = blob;

						// Stop the camera stream
						if (stream) {
							stream.getTracks().forEach((track) => track.stop());
						}

						// Hide camera and show loading
						hideCamera();
						showLoading();

						// Start the automatic workflow
						await processWorkflow();
					}
				}, "image/jpeg");
			});

			async function processWorkflow() {
				try {
					// Step 1: Analyze image with Moondream
					updateLoadingMessage("Analyzing image...");
					const moondreamResult = await analyzeImage();

					// Step 2: Extract JSON with OpenAI
					updateLoadingMessage("Extracting key information...");
					const extractedData = await extractJson(moondreamResult);

					// Step 3: Clean terms
					updateLoadingMessage("Cleaning terms...");
					const cleanedTerms = await cleanTerms(extractedData);

					// Step 4: Check Wikipedia
					updateLoadingMessage("Checking Wikipedia articles...");
					const wikipediaUrls = await checkWikipedia(cleanedTerms);

					if (wikipediaUrls.length === 0) {
						throw new Error("No Wikipedia articles found");
					}

					// Step 5: Fetch Wikipedia text
					updateLoadingMessage("Fetching article content...");
					const wikiArticles = await fetchWikipediaText(wikipediaUrls);

					if (wikiArticles.length === 0) {
						throw new Error("No Wikipedia articles retrieved");
					}

					// Step 6: Summarize articles
					updateLoadingMessage("Summarizing articles...");
					const summaries = await summarizeText(wikiArticles);

					if (summaries.length === 0) {
						throw new Error("No summaries generated");
					}

					// Step 7: Generate visualization
					updateLoadingMessage("Generating visualization...");
					const html = await generateVisualization(summaries);

					// Display the final result
					showVisualization(html);
				} catch (error) {
					updateLoadingMessage(
						`Error: ${error instanceof Error ? error.message : "Unknown error"}`,
					);
					console.error("Workflow error:", error);
				}
			}

			async function analyzeImage(): Promise<string> {
				if (!capturedBlob) throw new Error("No image captured");

				const formData = new FormData();
				formData.append("image", capturedBlob, "capture.jpg");

				const response = await fetch("/api/analyze", {
					method: "POST",
					body: formData,
				});

				const data = await response.json();

				if (!response.ok) {
					throw new Error(data.error || "Analysis failed");
				}

				return typeof data.result === "string"
					? data.result
					: JSON.stringify(data.result);
			}

			async function extractJson(
				moondreamResult: string,
			): Promise<{ items: string[] }> {
				const response = await fetch("/api/extract-json", {
					method: "POST",
					headers: { "Content-Type": "application/json" },
					body: JSON.stringify({ result: moondreamResult }),
				});

				const data = await response.json();

				if (!response.ok) {
					throw new Error(data.error || "Extraction failed");
				}

				return data.data;
			}

			async function cleanTerms(extractedData: {
				items: string[];
			}): Promise<string[]> {
				const items = extractedData.items;

				if (!Array.isArray(items) || items.length === 0) {
					throw new Error("No items to clean");
				}

				const response = await fetch("/api/clean-terms", {
					method: "POST",
					headers: { "Content-Type": "application/json" },
					body: JSON.stringify({ items }),
				});

				const data = await response.json();

				if (!response.ok) {
					throw new Error(data.error || "Term cleaning failed");
				}

				return data.data.items;
			}

			async function checkWikipedia(cleanedTerms: string[]): Promise<string[]> {
				const items = cleanedTerms;

				const response = await fetch("/api/check-wikipedia", {
					method: "POST",
					headers: { "Content-Type": "application/json" },
					body: JSON.stringify({ items }),
				});

				const data = await response.json();

				if (!response.ok) {
					throw new Error(data.error || "Wikipedia check failed");
				}

				const urls: string[] = [];
				for (const result of data.results) {
					if (result.exists) {
						urls.push(result.url);
					}
				}

				return urls;
			}

			async function fetchWikipediaText(
				urls: string[],
			): Promise<WikiArticle[]> {
				const response = await fetch("/api/fetch-wikipedia-text", {
					method: "POST",
					headers: { "Content-Type": "application/json" },
					body: JSON.stringify({ urls }),
				});

				const data = await response.json();

				if (!response.ok) {
					throw new Error(data.error || "Failed to fetch Wikipedia text");
				}

				const articles: WikiArticle[] = [];
				for (const result of data.results) {
					if (!result.error && result.title && result.text) {
						articles.push({
							title: result.title,
							text: result.text,
						});
					}
				}

				return articles;
			}

			async function summarizeText(
				articles: WikiArticle[],
			): Promise<Summary[]> {
				const summaries: Summary[] = [];

				// Process articles one at a time with streaming
				for (let i = 0; i < articles.length; i++) {
					const article = articles[i];

					try {
						const summary = await summarizeArticleStreaming(article, i + 1, articles.length);
						summaries.push({
							title: article.title,
							summary: summary,
						});
					} catch (error) {
						console.error(`Failed to summarize ${article.title}:`, error);
						// Continue with next article instead of failing completely
					}
				}

				return summaries;
			}

			async function summarizeArticleStreaming(
				article: WikiArticle,
				currentIndex: number,
				totalCount: number,
			): Promise<string> {
				const response = await fetch("/api/summarize-stream", {
					method: "POST",
					headers: { "Content-Type": "application/json" },
					body: JSON.stringify({ article }),
				});

				if (!response.ok) {
					throw new Error(`Failed to summarize ${article.title}`);
				}

				// Read the stream and accumulate the text
				const reader = response.body?.getReader();
				if (!reader) {
					throw new Error("No response body reader available");
				}

				const decoder = new TextDecoder();
				let fullText = "";

				while (true) {
					const { done, value } = await reader.read();

					if (done) break;

					// Decode the chunk - it's plain text, not JSON
					const chunk = decoder.decode(value, { stream: true });
					fullText += chunk;

					// Extract the last word for display
					const words = fullText.trim().split(/\s+/);
					const lastWord = words[words.length - 1] || "";

					// Update the loading message using separate parts to prevent layout jump
					updateLoadingMessageParts(
						`Summarizing (${currentIndex}/${totalCount})`,
						`${lastWord}...`,
					);
				}

				return fullText.trim();
			}

			async function generateVisualization(
				summaries: Summary[],
			): Promise<string> {
				const response = await fetch("/api/generate-visualization", {
					method: "POST",
					headers: { "Content-Type": "application/json" },
					body: JSON.stringify({ summaries }),
				});

				const data = await response.json();

				if (!response.ok) {
					throw new Error(data.error || "Failed to generate visualization");
				}

				return data.html;
			}

			function showVisualization(html: string) {
				// Hide camera container completely
				cameraContainer.style.display = "none";

				// Create and display iframe with inline styles
				visualizationContainer.innerHTML = "";
				const iframe = document.createElement("iframe");
				iframe.srcdoc = html;
				iframe.style.width = "100%";
				iframe.style.height = "100%";
				iframe.style.border = "none";
				iframe.style.margin = "0";
				iframe.style.padding = "0";
				iframe.style.display = "block";
				visualizationContainer.appendChild(iframe);
				visualizationContainer.classList.remove("hidden");
			}
		</script>
	</body>
</html>
