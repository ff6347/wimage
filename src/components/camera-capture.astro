<!-- ABOUTME: Camera capture component that accesses webcam and sends images to Moondream API --><!-- ABOUTME: Handles video stream, image capture, and query submission -->
<div class="camera-container">
	<video id="video" autoplay playsinline></video>
	<canvas id="canvas" class="hidden"></canvas>

	<div class="button-container">
		<button id="startCamera">Start Camera</button>
		<button id="capture" disabled>Capture Image</button>
	</div>

	<section class="query hidden">
		<img id="capturedImage" alt="Captured image" />
		<div class="button-container">
			<button id="analyze">Analyze</button>
		</div>
		<div class="api-info hidden" id="analyzeApiInfo"></div>
		<div class="result-container" id="results"></div>
	</section>

	<section class="extract hidden">
		<div class="button-container">
			<button id="extractJson">Extract JSON</button>
		</div>
		<div class="api-info hidden" id="extractApiInfo"></div>
		<div class="result-container" id="extractedResults"></div>
	</section>

	<section class="clean hidden">
		<div class="button-container">
			<button id="cleanTerms">Clean Terms</button>
		</div>
		<div class="api-info hidden" id="cleanApiInfo"></div>
		<div class="result-container" id="cleanedResults"></div>
	</section>

	<section class="wikipedia hidden">
		<div class="button-container">
			<button id="checkWikipedia">Check Wikipedia</button>
		</div>
		<div class="api-info hidden" id="wikipediaApiInfo"></div>
		<div class="result-container" id="wikipediaResults"></div>
	</section>

	<section class="fetch-text hidden">
		<div class="button-container">
			<button id="fetchWikiText">Fetch Wikipedia Text</button>
		</div>
		<div class="api-info hidden" id="fetchTextApiInfo"></div>
		<div class="result-container" id="wikiTextResults"></div>
	</section>

	<section class="summarize hidden">
		<div class="button-container">
			<button id="summarizeText">Summarize Articles</button>
		</div>
		<div class="api-info hidden" id="summarizeApiInfo"></div>
		<div class="summarize-status" id="summarizeStatus"></div>
		<div class="result-container" id="summaryResults"></div>
	</section>

	<section class="visualize hidden">
		<div class="button-container">
			<button id="visualizeText">Visualize Summaries</button>
		</div>
		<div class="api-info hidden" id="visualizeApiInfo"></div>
		<div id="iframeContainer"></div>
	</section>
</div>

<style>
	.camera-container {
		width: 640px;
		max-width: 100%;
		display: flex;
		flex-direction: column;
		gap: 8px;
	}

	video {
		width: 100%;
		height: auto;
		aspect-ratio: 4 / 3;
		background: lightgray;
	}

	.button-container {
		display: flex;
		gap: 8px;
		justify-content: center;
		margin-top: 16px;
	}

	.button-container button {
		min-width: 200px;
	}

	section {
		display: flex;
		flex-direction: column;
		gap: 8px;
		animation: expandIn 0.3s ease-out;
	}

	@keyframes expandIn {
		from {
			opacity: 0;
			max-height: 0;
			overflow: hidden;
		}
		to {
			opacity: 1;
			max-height: 2000px;
		}
	}

	.query img {
		width: 100%;
		height: auto;
	}

	.result-container {
		padding: 20px;
		background-color: lightgray;
		min-height: 50px;
	}

	.wikipedia .result-container a {
		color: #1976d2;
		text-decoration: none;
	}

	.wikipedia .result-container a:hover {
		text-decoration: underline;
	}

	.fetch-text .result-container details {
		padding: 10px;
		background-color: white;
		border: 1px solid #ddd;
	}

	.fetch-text .result-container summary {
		cursor: pointer;
		font-weight: bold;
		padding: 5px;
	}

	.fetch-text .result-container summary:hover {
		background-color: #f5f5f5;
	}

	.fetch-text .result-container pre {
		white-space: pre-wrap;
		word-wrap: break-word;
		margin-top: 8px;
		font-size: 14px;
		line-height: 1.4;
	}

	.summarize .summary-item {
		padding: 15px;
		background-color: white;
		border-left: 4px solid #9c27b0;
		margin-bottom: 8px;
	}

	.summarize .summary-item:last-child {
		margin-bottom: 0;
	}

	.summarize .summary-item h4 {
		margin: 0 0 8px 0;
		color: #7b1fa2;
	}

	.summarize .summary-item p {
		margin: 0;
		line-height: 1.6;
		color: #333;
	}

	#iframeContainer iframe {
		width: 100%;
		min-height: 600px;
		border: 4px solid #667eea;
		box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
	}

	.api-info {
		padding: 12px;
		background-color: #e3f2fd;
		font-size: 14px;
		margin-bottom: 8px;
	}

	.api-info strong {
		color: #0066cc;
	}

	.api-info .prompt {
		margin-top: 8px;
		padding: 8px;
		background-color: white;
		font-family: monospace;
		font-size: 12px;
		white-space: pre-wrap;
		word-wrap: break-word;
		overflow-wrap: break-word;
		word-break: break-word;
		border-left: 3px solid #0066cc;
		max-height: none;
		overflow: visible;
	}

	.summarize-status {
		padding: 12px;
		background-color: lightgray;
		font-size: 14px;
		color: lightslategray;
		margin-bottom: 8px;
		font-weight: 500;
	}
</style>

<script>
	interface WikiArticle {
		title: string;
		text: string;
	}

	interface Summary {
		title: string;
		summary: string;
	}

	let stream: MediaStream | null = null;
	let capturedBlob: Blob | null = null;
	let moondreamResult: string | null = null;
	let extractedData: unknown = null;
	let cleanedTerms: string[] = [];
	let wikipediaUrls: string[] = [];
	let wikiArticles: WikiArticle[] = [];
	let summaries: Summary[] = [];

	const video = document.getElementById("video") as HTMLVideoElement;
	const canvas = document.getElementById("canvas") as HTMLCanvasElement;
	const startCameraBtn = document.getElementById(
		"startCamera",
	) as HTMLButtonElement;
	const captureBtn = document.getElementById("capture") as HTMLButtonElement;
	const analyzeBtn = document.getElementById("analyze") as HTMLButtonElement;
	const extractJsonBtn = document.getElementById(
		"extractJson",
	) as HTMLButtonElement;
	const cleanTermsBtn = document.getElementById(
		"cleanTerms",
	) as HTMLButtonElement;
	const checkWikipediaBtn = document.getElementById(
		"checkWikipedia",
	) as HTMLButtonElement;
	const fetchWikiTextBtn = document.getElementById(
		"fetchWikiText",
	) as HTMLButtonElement;
	const summarizeTextBtn = document.getElementById(
		"summarizeText",
	) as HTMLButtonElement;
	const visualizeTextBtn = document.getElementById(
		"visualizeText",
	) as HTMLButtonElement;
	const capturedImage = document.getElementById(
		"capturedImage",
	) as HTMLImageElement;

	const querySection = document.querySelector(".query") as HTMLElement;
	const extractSection = document.querySelector(".extract") as HTMLElement;
	const cleanSection = document.querySelector(".clean") as HTMLElement;
	const wikipediaSection = document.querySelector(".wikipedia") as HTMLElement;
	const fetchTextSection = document.querySelector(".fetch-text") as HTMLElement;
	const summarizeSection = document.querySelector(".summarize") as HTMLElement;
	const visualizeSection = document.querySelector(".visualize") as HTMLElement;

	const resultsDiv = document.getElementById("results") as HTMLDivElement;
	const extractedResultsDiv = document.getElementById(
		"extractedResults",
	) as HTMLDivElement;
	const cleanedResultsDiv = document.getElementById(
		"cleanedResults",
	) as HTMLDivElement;
	const wikipediaResultsDiv = document.getElementById(
		"wikipediaResults",
	) as HTMLDivElement;
	const wikiTextResultsDiv = document.getElementById(
		"wikiTextResults",
	) as HTMLDivElement;
	const summaryResultsDiv = document.getElementById(
		"summaryResults",
	) as HTMLDivElement;
	const summarizeStatusDiv = document.getElementById(
		"summarizeStatus",
	) as HTMLDivElement;
	const iframeContainer = document.getElementById(
		"iframeContainer",
	) as HTMLDivElement;

	// Keyboard shortcut for toggling all sections (Cmd/Ctrl + Shift + D)
	document.addEventListener("keydown", (e) => {
		if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === "D") {
			e.preventDefault();
			const sections = [
				querySection,
				extractSection,
				cleanSection,
				wikipediaSection,
				fetchTextSection,
				summarizeSection,
				visualizeSection,
			];
			sections.forEach((section) => section.classList.toggle("hidden"));
		}
	});

	const analyzeApiInfoDiv = document.getElementById(
		"analyzeApiInfo",
	) as HTMLDivElement;
	const extractApiInfoDiv = document.getElementById(
		"extractApiInfo",
	) as HTMLDivElement;
	const cleanApiInfoDiv = document.getElementById(
		"cleanApiInfo",
	) as HTMLDivElement;
	const wikipediaApiInfoDiv = document.getElementById(
		"wikipediaApiInfo",
	) as HTMLDivElement;
	const fetchTextApiInfoDiv = document.getElementById(
		"fetchTextApiInfo",
	) as HTMLDivElement;
	const summarizeApiInfoDiv = document.getElementById(
		"summarizeApiInfo",
	) as HTMLDivElement;
	const visualizeApiInfoDiv = document.getElementById(
		"visualizeApiInfo",
	) as HTMLDivElement;

	function escapeHtml(text: string): string {
		const div = document.createElement("div");
		div.textContent = text;
		return div.innerHTML;
	}

	async function fetchAndDisplayApiInfo(
		endpoint: string,
		infoDiv: HTMLElement,
	) {
		try {
			const response = await fetch(endpoint);
			const info = await response.json();

			let html = `<strong>${info.description}</strong>`;

			if (info.model) {
				html += `<br><strong>Model:</strong> ${info.model}`;
			}

			if (info.apiUsed) {
				html += `<br><strong>API:</strong> ${info.apiUsed}`;
			}

			if (info.systemPrompt) {
				html += `<div class="prompt">${escapeHtml(info.systemPrompt)}</div>`;
			}

			if (info.query) {
				html += `<div class="prompt">${escapeHtml(info.query)}</div>`;
			}

			infoDiv.innerHTML = html;
			infoDiv.classList.remove("hidden");
		} catch (error) {
			console.error("Error fetching API info:", error);
		}
	}

	async function showSection(
		section: HTMLElement,
		apiEndpoint?: string,
		apiInfoDiv?: HTMLElement,
	) {
		section.classList.remove("hidden");
		if (apiEndpoint && apiInfoDiv) {
			await fetchAndDisplayApiInfo(apiEndpoint, apiInfoDiv);
		}
	}

	function setStatus(
		element: HTMLElement,
		message: string,
		type: "error" | "info" = "info",
	) {
		element.textContent = message;
		element.className = `result-container ${type}`;
	}

	startCameraBtn.addEventListener("click", async () => {
		try {
			stream = await navigator.mediaDevices.getUserMedia({
				video: { facingMode: "user" },
			});
			video.srcObject = stream;
			captureBtn.disabled = false;
			startCameraBtn.disabled = true;
		} catch (error) {
			alert(
				`Error accessing camera: ${error instanceof Error ? error.message : "Unknown error"}`,
			);
		}
	});

	captureBtn.addEventListener("click", () => {
		const context = canvas.getContext("2d");
		if (!context) return;

		canvas.width = video.videoWidth;
		canvas.height = video.videoHeight;
		context.drawImage(video, 0, 0);

		canvas.toBlob(async (blob) => {
			if (blob) {
				capturedBlob = blob;
				capturedImage.src = URL.createObjectURL(blob);
				await showSection(querySection, "/api/analyze", analyzeApiInfoDiv);
				setStatus(resultsDiv, "Image captured! Click Analyze.");
			}
		}, "image/jpeg");
	});

	analyzeBtn.addEventListener("click", async () => {
		if (!capturedBlob) {
			setStatus(resultsDiv, "No image captured", "error");
			return;
		}

		setStatus(resultsDiv, "Analyzing...");
		analyzeBtn.disabled = true;

		try {
			const formData = new FormData();
			formData.append("image", capturedBlob, "capture.jpg");

			const response = await fetch("/api/analyze", {
				method: "POST",
				body: formData,
			});

			const data = await response.json();

			if (!response.ok) {
				throw new Error(data.error || "Analysis failed");
			}

			moondreamResult =
				typeof data.result === "string"
					? data.result
					: JSON.stringify(data.result);

			resultsDiv.innerHTML = `<h3>Results:</h3><pre>${JSON.stringify(data.result, null, 2)}</pre>`;
			await showSection(extractSection, "/api/extract-json", extractApiInfoDiv);
		} catch (error) {
			setStatus(
				resultsDiv,
				`Error: ${error instanceof Error ? error.message : "Unknown error"}`,
				"error",
			);
		} finally {
			analyzeBtn.disabled = false;
		}
	});

	extractJsonBtn.addEventListener("click", async () => {
		if (!moondreamResult) {
			setStatus(extractedResultsDiv, "No Moondream result to extract", "error");
			return;
		}

		setStatus(extractedResultsDiv, "Extracting JSON...");
		extractJsonBtn.disabled = true;

		try {
			const response = await fetch("/api/extract-json", {
				method: "POST",
				headers: { "Content-Type": "application/json" },
				body: JSON.stringify({ result: moondreamResult }),
			});

			const data = await response.json();

			if (!response.ok) {
				throw new Error(data.error || "Extraction failed");
			}

			extractedData = data.data;

			extractedResultsDiv.innerHTML = `<h3>Extracted JSON:</h3><pre>${JSON.stringify(data.data, null, 2)}</pre>`;
			await showSection(cleanSection, "/api/clean-terms", cleanApiInfoDiv);
		} catch (error) {
			setStatus(
				extractedResultsDiv,
				`Error: ${error instanceof Error ? error.message : "Unknown error"}`,
				"error",
			);
		} finally {
			extractJsonBtn.disabled = false;
		}
	});

	cleanTermsBtn.addEventListener("click", async () => {
		if (!extractedData) {
			setStatus(cleanedResultsDiv, "No extracted data to clean", "error");
			return;
		}

		let items: string[] = [];
		if (typeof extractedData === "object" && extractedData !== null) {
			const dataObj = extractedData as { items?: string[] };
			if (dataObj.items && Array.isArray(dataObj.items)) {
				items = dataObj.items;
			}
		}

		if (items.length === 0) {
			setStatus(cleanedResultsDiv, "No items found in extracted data", "error");
			return;
		}

		setStatus(cleanedResultsDiv, "Cleaning terms...");
		cleanTermsBtn.disabled = true;

		try {
			const response = await fetch("/api/clean-terms", {
				method: "POST",
				headers: { "Content-Type": "application/json" },
				body: JSON.stringify({ items }),
			});

			const data = await response.json();

			if (!response.ok) {
				throw new Error(data.error || "Term cleaning failed");
			}

			cleanedTerms = data.data.items;

			cleanedResultsDiv.innerHTML = `
				<h3>Original Terms:</h3>
				<pre>${JSON.stringify(items, null, 2)}</pre>
				<h3>Cleaned Terms:</h3>
				<pre>${JSON.stringify(cleanedTerms, null, 2)}</pre>
			`;
			await showSection(
				wikipediaSection,
				"/api/check-wikipedia",
				wikipediaApiInfoDiv,
			);
		} catch (error) {
			setStatus(
				cleanedResultsDiv,
				`Error: ${error instanceof Error ? error.message : "Unknown error"}`,
				"error",
			);
		} finally {
			cleanTermsBtn.disabled = false;
		}
	});

	checkWikipediaBtn.addEventListener("click", async () => {
		if (cleanedTerms.length === 0) {
			setStatus(wikipediaResultsDiv, "No cleaned terms to check", "error");
			return;
		}

		const items: string[] = cleanedTerms;

		setStatus(wikipediaResultsDiv, "Checking Wikipedia...");
		checkWikipediaBtn.disabled = true;

		try {
			const response = await fetch("/api/check-wikipedia", {
				method: "POST",
				headers: { "Content-Type": "application/json" },
				body: JSON.stringify({ items }),
			});

			const data = await response.json();

			if (!response.ok) {
				throw new Error(data.error || "Wikipedia check failed");
			}

			wikipediaUrls = [];
			let resultsHtml = "<h3>Wikipedia Results:</h3><ul>";
			for (const result of data.results) {
				if (result.exists) {
					wikipediaUrls.push(result.url);
					resultsHtml += `<li><strong>${result.term}</strong>: <a href="${result.url}" target="_blank">Article exists</a></li>`;
				} else {
					resultsHtml += `<li><strong>${result.term}</strong>: No article found</li>`;
				}
			}
			resultsHtml += "</ul>";

			wikipediaResultsDiv.innerHTML = resultsHtml;

			if (wikipediaUrls.length > 0) {
				await showSection(
					fetchTextSection,
					"/api/fetch-wikipedia-text",
					fetchTextApiInfoDiv,
				);
			}
		} catch (error) {
			setStatus(
				wikipediaResultsDiv,
				`Error: ${error instanceof Error ? error.message : "Unknown error"}`,
				"error",
			);
		} finally {
			checkWikipediaBtn.disabled = false;
		}
	});

	fetchWikiTextBtn.addEventListener("click", async () => {
		if (wikipediaUrls.length === 0) {
			setStatus(wikiTextResultsDiv, "No Wikipedia URLs to fetch", "error");
			return;
		}

		setStatus(wikiTextResultsDiv, "Fetching Wikipedia article text...");
		fetchWikiTextBtn.disabled = true;

		try {
			const response = await fetch("/api/fetch-wikipedia-text", {
				method: "POST",
				headers: { "Content-Type": "application/json" },
				body: JSON.stringify({ urls: wikipediaUrls }),
			});

			const data = await response.json();

			if (!response.ok) {
				throw new Error(data.error || "Failed to fetch Wikipedia text");
			}

			wikiArticles = [];
			let resultsHtml = "<h3>Wikipedia Article Text:</h3>";
			for (const result of data.results) {
				if (result.error) {
					resultsHtml += `<details><summary>${result.url} - Error</summary><p>${result.error}</p></details>`;
				} else {
					wikiArticles.push({
						title: result.title,
						text: result.text,
					});
					resultsHtml += `
						<details>
							<summary>${result.title || result.url}</summary>
							<p><strong>Preview:</strong></p>
							<pre>${result.preview || ""}</pre>
							<p><strong>Full Text:</strong></p>
							<pre>${result.text || ""}</pre>
						</details>
					`;
				}
			}

			wikiTextResultsDiv.innerHTML = resultsHtml;

			if (wikiArticles.length > 0) {
				await showSection(
					summarizeSection,
					"/api/summarize-stream",
					summarizeApiInfoDiv,
				);
			}
		} catch (error) {
			setStatus(
				wikiTextResultsDiv,
				`Error: ${error instanceof Error ? error.message : "Unknown error"}`,
				"error",
			);
		} finally {
			fetchWikiTextBtn.disabled = false;
		}
	});

	summarizeTextBtn.addEventListener("click", async () => {
		if (wikiArticles.length === 0) {
			setStatus(summaryResultsDiv, "No articles to summarize", "error");
			return;
		}

		summarizeStatusDiv.textContent = "Starting summarization...";
		summarizeTextBtn.disabled = true;

		try {
			summaries = [];
			summaryResultsDiv.innerHTML = "<h3>Article Summaries:</h3>";

			// Process articles one at a time with streaming
			for (let i = 0; i < wikiArticles.length; i++) {
				const article = wikiArticles[i];

				// Create a container for this article's summary
				const summaryItem = document.createElement("div");
				summaryItem.className = "summary-item";
				summaryItem.innerHTML = `
					<h4>${article.title}</h4>
					<p class="summary-text"></p>
				`;
				summaryResultsDiv.appendChild(summaryItem);
				const summaryText = summaryItem.querySelector(
					".summary-text",
				) as HTMLParagraphElement;

				try {
					const summary = await summarizeArticleStreaming(
						article,
						i + 1,
						wikiArticles.length,
						summaryText,
					);
					summaries.push({
						title: article.title,
						summary: summary,
					});
				} catch (error) {
					console.error(`Failed to summarize ${article.title}:`, error);
					summaryText.style.color = "#d32f2f";
					summaryText.textContent = `Error: ${error instanceof Error ? error.message : "Unknown error"}`;
				}
			}

			summarizeStatusDiv.textContent = "âœ“ Summarization complete!";

			if (summaries.length > 0) {
				await showSection(
					visualizeSection,
					"/api/generate-visualization-stream",
					visualizeApiInfoDiv,
				);
			}
		} catch (error) {
			summarizeStatusDiv.textContent = `Error: ${error instanceof Error ? error.message : "Unknown error"}`;
			summarizeStatusDiv.style.color = "#d32f2f";
		} finally {
			summarizeTextBtn.disabled = false;
		}
	});

	async function summarizeArticleStreaming(
		article: WikiArticle,
		currentIndex: number,
		totalCount: number,
		summaryElement: HTMLParagraphElement,
	): Promise<string> {
		const response = await fetch("/api/summarize-stream", {
			method: "POST",
			headers: { "Content-Type": "application/json" },
			body: JSON.stringify({ article }),
		});

		if (!response.ok) {
			throw new Error(`Failed to summarize ${article.title}`);
		}

		// Read the stream and accumulate the text
		const reader = response.body?.getReader();
		if (!reader) {
			throw new Error("No response body reader available");
		}

		const decoder = new TextDecoder();
		let fullText = "";

		while (true) {
			const { done, value } = await reader.read();

			if (done) break;

			// Decode the chunk - it's plain text, not JSON
			const chunk = decoder.decode(value, { stream: true });
			fullText += chunk;

			// Update the paragraph with the accumulated text
			summaryElement.textContent = fullText;

			// Scroll the summary element into view
			summaryElement.scrollIntoView({ behavior: "smooth", block: "end" });

			// Extract the last word for display in status
			const words = fullText.trim().split(/\s+/);
			const lastWord = words[words.length - 1] || "";

			// Update the status message with current word
			summarizeStatusDiv.textContent = `Summarizing (${currentIndex}/${totalCount}) ${lastWord}...`;
		}

		return fullText.trim();
	}

	visualizeTextBtn.addEventListener("click", async () => {
		if (summaries.length === 0) {
			alert("No summaries to visualize");
			return;
		}

		iframeContainer.innerHTML = "<p>Generating visualization...</p>";
		visualizeTextBtn.disabled = true;

		try {
			console.log("Fetching visualization...");
			const response = await fetch("/api/generate-visualization", {
				method: "POST",
				headers: { "Content-Type": "application/json" },
				body: JSON.stringify({ summaries }),
			});

			console.log("Response status:", response.status);
			const data = await response.json();

			if (!response.ok) {
				throw new Error(data.error || "Failed to generate visualization");
			}

			iframeContainer.innerHTML = "";

			const iframe = document.createElement("iframe");
			iframe.style.width = "100%";
			iframe.style.minHeight = "600px";
			iframe.style.border = "none";
			iframe.srcdoc = data.html;

			iframeContainer.appendChild(iframe);

			iframe.scrollIntoView({ behavior: "smooth", block: "start" });
		} catch (error) {
			console.error("Visualization error:", error);
			iframeContainer.innerHTML = `<p style="color: #d32f2f;">Error: ${error instanceof Error ? error.message : "Unknown error"}</p>`;
		} finally {
			visualizeTextBtn.disabled = false;
		}
	});
</script>
